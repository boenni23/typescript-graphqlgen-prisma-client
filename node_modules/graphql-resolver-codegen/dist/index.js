#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var yargs = require("yargs");
var graphql_1 = require("graphql");
var fs = require("fs");
var chalk = require("chalk");
var source_helper_1 = require("./source-helper");
var path_1 = require("path");
var ts_generator_1 = require("./generators/ts-generator");
var reason_generator_1 = require("./generators/reason-generator");
var graphql_import_1 = require("graphql-import");
function getGenerator(generator) {
    if (generator === "reason") {
        return { generate: reason_generator_1.generate, format: reason_generator_1.format };
    }
    return { generate: ts_generator_1.generate, format: ts_generator_1.format };
}
function generateCode(_a) {
    var _b = _a.schema, schema = _b === void 0 ? undefined : _b, _c = _a.prettify, prettify = _c === void 0 ? true : _c, _d = _a.generator, generator = _d === void 0 ? "typescript" : _d;
    if (!schema) {
        console.error(chalk.default.red("Please provide a parsed GraphQL schema"));
    }
    var generateArgs = {
        types: source_helper_1.extractGraphQLTypes(schema),
        enums: source_helper_1.extractGraphQLEnums(schema),
        unions: source_helper_1.extractGraphQLUnions(schema)
    };
    var generatorFn = getGenerator(generator);
    var code = generatorFn.generate(generateArgs);
    if (prettify) {
        return generatorFn.format(code);
    }
    else {
        return code;
    }
}
exports.generateCode = generateCode;
function run() {
    var defaults = {
        output: "./resolvers.ts",
        generator: "typescript"
    };
    var argv = yargs
        .usage("Usage: $0 -s [schema-path] -o [output-path] -g [generator]")
        .alias("s", "schema-path")
        .describe("s", "GraphQL schema file path")
        .alias("o", "output")
        .describe("o", "Output file path [default: " + defaults.output + "]")
        .alias("g", "generator")
        .describe("g", "Generator to use [default: " + defaults.generator + ", options: reason]")
        .demandOption(["s"])
        .strict().argv;
    var args = {
        schemaPath: path_1.resolve(argv.schemaPath),
        output: argv.output || defaults.output,
        generator: argv.generator || defaults.generator
    };
    if (!fs.existsSync(args.schemaPath)) {
        console.error("The schema file " + args.schemaPath + " does not exist");
        process.exit(1);
    }
    var schema = undefined;
    try {
        schema = graphql_import_1.importSchema(args.schemaPath);
    }
    catch (e) {
        console.error(chalk.default.red("Error occurred while reading schema: " + e));
        process.exit(1);
    }
    var parsedSchema = undefined;
    try {
        parsedSchema = graphql_1.parse(schema);
    }
    catch (e) {
        console.error(chalk.default.red("Failed to parse schema: " + e));
        process.exit(1);
    }
    var code = generateCode({
        schema: parsedSchema,
        generator: args.generator
    });
    try {
        fs.writeFileSync(args.output, code, { encoding: "utf-8" });
    }
    catch (e) {
        console.error(chalk.default.red("Failed to write the file at " + args.output + ", error: " + e));
        process.exit(1);
    }
    console.log(chalk.default.green("Code generated at " + args.output));
    process.exit(0);
}
// Only call run when running from CLI, not when included for tests
if (require.main === module) {
    run();
}
//# sourceMappingURL=index.js.map
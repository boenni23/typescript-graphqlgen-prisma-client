"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var capitalize = require("capitalize");
var prettier = require("prettier");
var source_helper_1 = require("../source-helper");
function getTypeFromGraphQLType(type) {
    if (type === "Int" || type === "Float") {
        return "number";
    }
    if (type === "Boolean") {
        return "boolean";
    }
    if (type === "String" || type === "ID" || type === "DateTime") {
        return "string";
    }
    return "string";
}
function format(code) {
    try {
        return prettier.format(code, {
            parser: "typescript"
        });
    }
    catch (e) {
        console.log("There is a syntax error in generated code, unformatted code printed, error: " + JSON.stringify(e));
        return code;
    }
}
exports.format = format;
function generate(args) {
    return "\nimport { GraphQLResolveInfo } from 'graphql'\n\nexport interface ResolverFn<Root, Args, Ctx, Payload> {\n  (root: Root, args: Args, ctx: Ctx, info: GraphQLResolveInfo):\n    | Payload\n    | Promise<Payload>\n}\n\nexport interface ITypes {\nContext: any\n" + args.enums.map(function (e) { return e.name + "Root: any"; }).join(os.EOL) + "\n" + args.unions.map(function (union) { return union.name + "Root: any"; }).join(os.EOL) + "\n" + args.types.map(function (type) { return type.name + "Root: any"; }).join(os.EOL) + "\n}\n\n  " + args.types
        .map(function (type) { return "export namespace I" + type.name + " {\n  " + type.fields
        .map(function (field) { return (field.arguments.length > 0
        ? "export interface Args" + capitalize(field.name) + " {\n      " + field.arguments
            .map(function (arg) {
            return arg.name + ": " + (source_helper_1.GraphQLScalarTypeArray.indexOf(arg.type.name) > -1
                ? getTypeFromGraphQLType(arg.type.name)
                : "T['" + field.type.name + "Root']") + (field.type.isArray ? "[]" : "");
        })
            .join(os.EOL) + "\n    }"
        : "") + "\n\n  export type " + capitalize(field.name) + "Resolver<T extends ITypes> = ResolverFn<\n    T['" + type.name + "Root'],\n    {},\n    T['Context'],\n    " + (source_helper_1.GraphQLScalarTypeArray.indexOf(field.type.name) > -1
        ? getTypeFromGraphQLType(field.type.name)
        : "T['" + field.type.name + "Root']") + (field.type.isArray ? "[]" : "") + "\n  >\n  "; })
        .join(os.EOL) + "\n\n  export interface Resolver<T extends ITypes> {\n  " + type.fields
        .map(function (field) { return "   " + field.name + ": " + capitalize(field.name) + "Resolver<T>"; })
        .join(os.EOL) + "\n  }\n}\n"; })
        .join(os.EOL) + "\n\nexport interface IResolvers<T extends ITypes> {\n  " + args.types
        .map(function (type) { return "   " + type.name + ": I" + type.name + ".Resolver<T>"; })
        .join(os.EOL) + "\n}\n\n  ";
}
exports.generate = generate;
//# sourceMappingURL=ts-generator.js.map